# Autogenerated with SMOP version 0.23
# ../smop/smop/main.py delsig/synthesizeQNTF.m
from __future__ import division, print_function
import numpy as np

def synthesizeQNTF(order=4,OSR=64,f0=0,NG=-60,ING=-20,n_im=None):
    """ntf = synthesizeQNTF(order=3,OSR=64,f0=0,NG=-60,ING=-20,n_im=floor(order/3))
    Synthesize a noise transfer function for a quadrature delta-sigma modulator.
      order  order of the modulator
      OSR    oversampling ratio
      f0     center frequency (1->fs)
      NG     in-band noise gain (dB)
      ING    image-band noise gain (dB)
      n_im   number of in-band image zeros

    ntf is a zpk object containing the zeros and poles of the NTF. See zpk.m

     ALPHA VERSION
     This function uses an experimental ad hoc method that is
     neither optimal nor robust.
     Handle the input arguments
    """
    if n_im is None:
        n_im = np.floor(order/3)
    debug_it = 0
    if n_im == 0:
        # Use synthesizeNTF to get an NTF with the specified NG; ignore ING
        f1 = 0.5/OSR
        x = 1.5
        lowest_f = np.inf
        dfdx = None
        for itn in range(1, 21):
            ntf = synthesizeNTF(order, OSR, 1., x)
            f = dbv(rmsGain(ntf, 0, f1)) - NG
            if debug_it:
                print('x=\n %.2f f=\n %.2f' % (x, f))
            if abs(f) < 0.01:
                break
            if dfdx is None:
                dx = 0.1*np.sign(f)
                dfdx = 0
            else:
                dfdx = (f - f_old)/dx
                dx_old = dx
                dx = - f/dfdx
                if abs(dx) > max(1, 2*abs(dx_old)):
                    dx = np.sign(dx)*max(1, 2*abs(dx_old))
                if x + dx <= 1:
                    # Hinf must be at least 1
                    dx = dx/2.
            f_old = f
            x = x + dx
        if itn == 20:
            warn('Warning: Iteration limit reached. NTF may be poor.')
        # Rotate the NTF
        z0 = np.exp(2j*np.pi*f0)
        ntf = lti(z0*ntf.zeros, z0*ntf.poles, ntf.k)
    else:
        n_in = order - n_im
        f1 = f0 - 0.5 / OSR
        f2 = f0 + 0.5 / OSR
        z0 = exp(2j*np.pi*f0))
        x = np.array([20, 20]).reshape(1, -1)
        # "R" parameters for cheby2()
        lowest_f = np.inf
        dfdx = np.array([NaN, NaN]).reshape(1, -1)
        for itn in range(1, 21):
            if debug_it:
                fprintf(1, 'x=[\n %.2f \n %.2f], ', x[0], x[1])
            b1, a1 = cheby2(n_in, x[0], 1 / OSR, 'high') # nargout=2
            b2, a2 = cheby2(n_im, x[1], 1 / OSR, 'high') # nargout=2
            warning('off')
            ntf0 = zpk(np.array([np.dot(roots(b1), z0), np.dot(roots(b2), conj(z0))]).reshape(1, -1), np.array([np.dot(roots(a1), z0), np.dot(roots(a2), conj(z0))]).reshape(1, -1), 1, 1)
            freq = linspace(- 0.5, 0.5, 200)
            m = evalTF(ntf0, exp(np.dot(np.dot(2j, pi), freq)))
            NG0 = dbv(rmsGain(ntf0, f1, f2))
            ING0 = dbv(rmsGain(ntf0, - f1, - f2))
            if debug_it:
                clf
                subplot(121)
                plotPZ(ntf0)
                subplot(122)
                fprintf(1, 'NG=\n %.1f, ING=\n %.1f\\n', NG0, ING0)
                plot(freq, dbv(m))
                figureMagic(np.array([- 0.5, 0.5]).reshape(1, -1), 0.05, 2, np.array([- 100, 30]).reshape(1, -1), 10, 2)
                hold('on')
                plot(np.array([f1, f2]).reshape(1, -1), np.dot(np.array([1, 1]).reshape(1, -1), NG0), 'k')
                text(mean(np.array([f1, f2]).reshape(1, -1)), NG0, sprintf('NG=\n %.1fdB', NG0), 'vert', 'bot')
                plot(np.array([- f1, - f2]).reshape(1, -1), np.dot(np.array([1, 1]).reshape(1, -1), ING0), 'k')
                text(mean(- np.array([f1, f2]).reshape(1, -1)), ING0, sprintf('ING=\n %.1fdB', ING0), 'vert', 'bot')
                drawnow
            f = np.array([NG0, ING0]).reshape(1, -1) - np.array([NG, ING]).reshape(1, -1)
            if abs(f) < 0.01:
                break
            if norm(f) < lowest_f:
                lowest_f = norm(f)
                best = ntf0
            if abs(f[0]) > abs(f[1]):
                i = 1
                # adjust x(1)
            else:
                i = 2
                # adjust x(2)
            if isnan(dfdx[(i -1)]):
                dx = sign(f[(i -1)])
                dfdx[(i -1)] = 0
                dfdx[(3 - i -1)] = NaN
            else:
                dfdx[(i -1)] = (f[(i -1)] - f_old[(i -1)]) / dx
                dfdx[(3 - i -1)] = NaN
                dx = - f[(i -1)] / dfdx[(i -1)]
                xnew = x[(i -1)] + dx
                if xnew < np.dot(0.5, x[(i -1)]):
                    dx = np.dot(- 0.5, x[(i -1)])
                else:
                    if xnew > np.dot(2, x[(i -1)]):
                        dx = x[(i -1)]
            f_old = f
            x[(i -1)] = x[(i -1)] + dx
        if itn == 20:
            warn('Warning: Iteration limit reached. NTF may be poor')
        ntf = best
    return ntf
